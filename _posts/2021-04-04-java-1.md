---
layout: post
title: Java
author: taku
date: 2021-04-04 18:30
last_modified_at: 2021-04-18 2:00
tags: [Java]
toc:  true
---

studying Java☕
Javaはコンパイラ言語

## HelloWorld.javaの実行手順

- 1.ソースプログラム

テキストエディタ等でプログラムを書く。

***HelloWorld.java***

```java
public class HelloWorld {
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        System.out.println("hello world");
    }   
}
```

- 2.コンパイル

コンパイラ(javac)を起動する。

```
javac HelloWorld.java
```

- 3.クラスファイル

Javaバイトコードに変換された **HelloWorld.class** が作成される。

- 4.実行

インタプリンタ(java)でクラスファイルを実行する。

```
java HelloWorld
```

- 5.実行結果

```
Hello, World!
```

## パッケージ

あるアプリケーションに関連するクラスやインターフェイスを整理するための名前空間である。

うーん？？？

- java.lang

Javaプログラミング言語の設計にあたり基本的なクラス

- java.util

レクション・フレームワーク、レガシー・コレクション・クラス、イベント・モデル、日時機能、国際化、およびさまざまなユーティリティ・クラス(StringTokenizer、乱数ジェネレータ、およびビット配列)が含まれている。

## コンストラクタ

コンストラクタは、インスタンスが生成されると実行される「初期化処理」。メソッドに似ているが、クラス名と**「同じ名前」**を使う。

## 継承

オブジェクト指向では、クラスに共通する「属性」・「振る舞い(メソッド)」をくり出し、より汎用的(一般的)なクラスを作成する。これを**「汎化」**という。

そして個々のクラスでは、汎用的なクラスと共通する内容はそのまま利用し、異なる部分だけを定義する。このようにクラスの共通内容を引き継ぐ仕組みを**「継承(インヘリタンス)」**することにする。

例

携帯電話Cellularと固定FixedPhoneに共通する「属性」・「振る舞い(メソッド)」を「電話Telephone」というクラスにまとめ(汎化)、これを「継承」する。

スーパークラスTelephone
***Telephone.java***

```java
public class Telephone {
    // インスタンス変数
    // 電話番号
    String telephoneNumber; 
    // メソッド
    // 着信
    public void receive(String caller) {
        System.out.println("ring! ring! ring!");
        System.out.println("Calling " + caller + " -> "
                                      + telephoneNumber);
    }
    // 通話
    public void talkSomethig(String msg){
        System.out.println("[" + msg + "]");
    }
    // 切断
    public void hungHp(){
        System.out.println("bye!");
    }
}
```

このスーパークラスからCellularPhoneを派生させる。
***CellularPhone.java***

```java
public class CellularPhone extends Telephone{
    // インスタンス変数を追加
    // 電池残量
    int batteryRemaining = 100;
    
    // コンストラクタの定義
    public CellularPhone(String telNum){
        telephoneNumber = telNum;
    }
    // hungUp()はTelephoneのものをオーバーライド(再定義)する
    public void hunbUp(){
        System.out.println("bye!");
        batteryRemaining = batteryRemaining - 10;
        System.out.println("batteryRemaining = " + batteryRemaining);
    }
}
```

クラス定義時にextends Telephoneと書くことでスーパークラス(Telephone)で定義されたインスタンス変数(telephoneNumber)、メソッド(receiveCall()、talkSomething()、hungUp())を引継ぐ。あとはTelePhoneとの差異である「電池残量(batteryRemaing)」を追加定義する。

また、CellularPhoneでは電池残量の更新・表示するためメソッドを再定義する。このようにスーパークラスのメソッド定義をサブクラスで変更することを「メソッドのオーバーライド(再定義)」と呼ぶ。

Javaインタプリンタはメソッド呼び出しを実行するとき、以下の順でメソッドを探索する。

1.指定されたインスタンスのクラス

2.スーパークラスを探す

3.そのスーパークラスを探す

4.最上位のクラス(Object)

## 多態性(ポリモルフィズム)

同じメッセージを送っても、受け手のオブジェクトのクラスにより振る舞いが異なることを「多態性」(ポリモルフィズム)という。

***Someone.java***

```java
public class Someone {
    public static void main(String[] args) {
        System.out.println("-------------------------------------");
        
        // CellularPhoneオブジェクトの生成
        CellularPhone cp = new CellularPhone("123-4567");
        polymorphism(cp);
        System.out.println("-------------------------------------");
        
        // FixedPhoneオフジェクトの生成
        FixedPhone fp = new FixedPhone("765-4321", "somewhere");
        polymorphism(fp);
        System.out.println("-------------------------------------");
    }
    // 多態性を利用したメソッドの呼び出し
    /* Telephone型の引数を取っているが、(見かけの型)
     * 実際はCellularPhoneとFixedPhoneのインスタンスが入るため、
     * 各々のクラスでオーバーライドしたメソッドが呼び出される
     * 例えば、CellularPhone型の場合hungUp()で最後に電池残量(batteryRemaining)が出力される
    */
    public static void polymorphism(Telephone tel){
            tel.receiveCall("987-6543");
            tel.hungUp();
        }
}
```

うーん、、なんとなく理解。。

## データ型と変数

プリミティブ型(基本型)：整数や実数など、値そのものを保持

参照型：オブジェクトや配列など、格納場所を保持

### 変数の種類

インスタンス変数：オブジェクトの属性を表す変数

クラス変数：あるクラスのオブジェクト全体で共有される変数

ローカル変数：メソッド内で一時的に使う変数

例

この中のsumとiはローカル変数

```java
public void sunInt(int n){
    int sum = 0;
    for(int i = 0; i <= n; i++;){
        sum += i;
    }
    System.out.println("sum of 1 to " + n + " = " + sum);
}
```

### 識別子

変数名の例：telephoneNumber, batteryRemaining

クラス名の例：CellularPhone, FixedPhone

定数の例：NUMBER_OB_MAX_LETTERS

メソッド名の例：receiveCall(), talkSomething(), hungUp()

### デフォルト値

基本0が入る。boolean型の場合、false

### 参照型

クラス型

文字列型:1文字以上の文字で構成された文字列はStringクラスのオブジェクト

```java
String telephoneNumber = "123-4567";
```

また、こう書くこともできる。

```java
String telephoneNumber = new String("123-4567").intern();
```

intern()メソッドはこちらを確認してください。

[intern()メソッド](https://programmer-life.work/java/interning-java)

要約すると、ヒープ領域という領域を節約するメソッド。String Constant Poolにあれば、そこから文字列を返してくれるというメソッドらしい。。

配列型

## 式と演算子

プリミティブ型の値の広さの関係

|  値の広さの関係  |  広い順 |
| ---- | ---- |
|  double  | 　↑ |
|  float  |  |
|  long  |  |
|  int, char  |  |
|  short  |  |
|  byte  | 　↓ |

以下のような、広い型で宣言する場合は実行でき、狭い型で宣言する場合はエラーになる。


```java
long l = 1234L; // 正しい　同じ型
float f = l;    // 正しい　flatの方が広い型
int i = f;      // コンパイルエラー。 intの方が狭い型
```

最後のような場合、キャストが必要になる。

```java
long l = 1234L; // 正しい　同じ型
float f = l;    // 正しい　flatの方が広い型。明示する必要がない(アップキャスト)
int i = (int)f; // キャストする。明示する必要がある(ダウンキャスト)
```

### 二項の数値格上げ変換

double型とint型を演算した際、値が広い型に変換される。

```java
int a = 5;
double b = 2.0;
System.out.println("a + b = " + a * b); // 出力：a + b = 10.0
```

となる。

これは、比較演算子でも同じ。

```java
int a = 5;
double b = 2.0;
boolean c = a <= b;                     // a,bともdouble型になり、比較する。
System.out.println("boolean c = " + c); // 出力；boolean c = false
```

文字などの参照型(文字列、クラス、配列)は比較の対象が参照先(メモリ)になるので、文字列が同じでも、等しくないと判定される。

文字列の比較はequals()を使う。

```java
String s1 = "hello";
String s2 = "hello";
if(s1.equals(s2)){
    System.out.println("s1 == s2");
}else{
    System.out.println("s1 != s2");
} // 出力：s1 == s2
```

### 論理演算子「&&」と「&」の違い

