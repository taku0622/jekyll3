---
layout: post
title: Java
author: taku
date: 2021-04-04 18:30
last_modified_at: 2021-04-28 2:00
tags: [Java]
toc:  true
---

studying Java☕
Javaはコンパイラ言語

## HelloWorld.javaの実行手順

- 1.ソースプログラム

テキストエディタ等でプログラムを書く。

***HelloWorld.java***

```java
public class HelloWorld {
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        System.out.println("hello world");
    }   
}
```

- 2.コンパイル

コンパイラ(javac)を起動する。

```
javac HelloWorld.java
```

- 3.クラスファイル

Javaバイトコードに変換された **HelloWorld.class** が作成される。

- 4.実行

インタプリンタ(java)でクラスファイルを実行する。

```
java HelloWorld
```

- 5.実行結果

```
Hello, World!
```

## パッケージ

あるアプリケーションに関連するクラスやインターフェイスを整理するための名前空間である。

うーん？？？

- java.lang

Javaプログラミング言語の設計にあたり基本的なクラス

- java.util

レクション・フレームワーク、レガシー・コレクション・クラス、イベント・モデル、日時機能、国際化、およびさまざまなユーティリティ・クラス(StringTokenizer、乱数ジェネレータ、およびビット配列)が含まれている。

## コンストラクタ

コンストラクタは、インスタンスが生成されると実行される「初期化処理」。メソッドに似ているが、クラス名と**「同じ名前」**を使う。

## 継承

オブジェクト指向では、クラスに共通する「属性」・「振る舞い(メソッド)」をくり出し、より汎用的(一般的)なクラスを作成する。これを**「汎化」**という。

そして個々のクラスでは、汎用的なクラスと共通する内容はそのまま利用し、異なる部分だけを定義する。このようにクラスの共通内容を引き継ぐ仕組みを**「継承(インヘリタンス)」**することにする。

例

携帯電話Cellularと固定FixedPhoneに共通する「属性」・「振る舞い(メソッド)」を「電話Telephone」というクラスにまとめ(汎化)、これを「継承」する。

スーパークラスTelephone
***Telephone.java***

```java
public class Telephone {
    // インスタンス変数
    // 電話番号
    String telephoneNumber; 
    // メソッド
    // 着信
    public void receive(String caller) {
        System.out.println("ring! ring! ring!");
        System.out.println("Calling " + caller + " -> "
                                      + telephoneNumber);
    }
    // 通話
    public void talkSomethig(String msg){
        System.out.println("[" + msg + "]");
    }
    // 切断
    public void hungHp(){
        System.out.println("bye!");
    }
}
```

このスーパークラスからCellularPhoneを派生させる。
***CellularPhone.java***

```java
public class CellularPhone extends Telephone{
    // インスタンス変数を追加
    // 電池残量
    int batteryRemaining = 100;
    
    // コンストラクタの定義
    public CellularPhone(String telNum){
        telephoneNumber = telNum;
    }
    // hungUp()はTelephoneのものをオーバーライド(再定義)する
    public void hunbUp(){
        System.out.println("bye!");
        batteryRemaining = batteryRemaining - 10;
        System.out.println("batteryRemaining = " + batteryRemaining);
    }
}
```

クラス定義時にextends Telephoneと書くことでスーパークラス(Telephone)で定義されたインスタンス変数(telephoneNumber)、メソッド(receiveCall()、talkSomething()、hungUp())を引継ぐ。あとはTelePhoneとの差異である「電池残量(batteryRemaing)」を追加定義する。

また、CellularPhoneでは電池残量の更新・表示するためメソッドを再定義する。このようにスーパークラスのメソッド定義をサブクラスで変更することを「メソッドのオーバーライド(再定義)」と呼ぶ。

Javaインタプリンタはメソッド呼び出しを実行するとき、以下の順でメソッドを探索する。

1.指定されたインスタンスのクラス

2.スーパークラスを探す

3.そのスーパークラスを探す

4.最上位のクラス(Object)

## 多態性(ポリモルフィズム)

同じメッセージを送っても、受け手のオブジェクトのクラスにより振る舞いが異なることを「多態性」(ポリモルフィズム)という。

***Someone.java***

```java
public class Someone {
    public static void main(String[] args) {
        System.out.println("-------------------------------------");
        
        // CellularPhoneオブジェクトの生成
        CellularPhone cp = new CellularPhone("123-4567");
        polymorphism(cp);
        System.out.println("-------------------------------------");
        
        // FixedPhoneオフジェクトの生成
        FixedPhone fp = new FixedPhone("765-4321", "somewhere");
        polymorphism(fp);
        System.out.println("-------------------------------------");
    }
    // 多態性を利用したメソッドの呼び出し
    /* Telephone型の引数を取っているが、(見かけの型)
     * 実際はCellularPhoneとFixedPhoneのインスタンスが入るため、
     * 各々のクラスでオーバーライドしたメソッドが呼び出される
     * 例えば、CellularPhone型の場合hungUp()で最後に電池残量(batteryRemaining)が出力される
    */
    public static void polymorphism(Telephone tel){
            tel.receiveCall("987-6543");
            tel.hungUp();
        }
}
```

うーん、、なんとなく理解。。

## データ型と変数

プリミティブ型(基本型)：整数や実数など、値そのものを保持

参照型：オブジェクトや配列など、格納場所を保持

### 変数の種類

インスタンス変数：オブジェクトの属性を表す変数

クラス変数：あるクラスのオブジェクト全体で共有される変数

ローカル変数：メソッド内で一時的に使う変数

例

この中のsumとiはローカル変数

```java
public void sunInt(int n){
    int sum = 0;
    for(int i = 0; i <= n; i++;){
        sum += i;
    }
    System.out.println("sum of 1 to " + n + " = " + sum);
}
```

### 識別子

変数名の例：telephoneNumber, batteryRemaining

クラス名の例：CellularPhone, FixedPhone

定数の例：NUMBER_OB_MAX_LETTERS

メソッド名の例：receiveCall(), talkSomething(), hungUp()

### デフォルト値

基本0が入る。boolean型の場合、false

### 参照型

クラス型

文字列型:1文字以上の文字で構成された文字列はStringクラスのオブジェクト

```java
String telephoneNumber = "123-4567";
```

また、こう書くこともできる。

```java
String telephoneNumber = new String("123-4567").intern();
```

intern()メソッドはこちらを確認してください。

[intern()メソッド](https://programmer-life.work/java/interning-java)

要約すると、ヒープ領域という領域を節約するメソッド。String Constant Poolにあれば、そこから文字列を返してくれるというメソッドらしい。。

配列型

```java
int[] arr = new int[7];
```

このように宣言すると、デフォルト値として ***0*** が入る。
静的だと慣れないよね

## 式と演算子

プリミティブ型の値の広さの関係

|  値の広さの関係  |  広い順 |
| ---- | ---- |
|  double  | 　↑ |
|  float  |  |
|  long  |  |
|  int, char  |  |
|  short  |  |
|  byte  | 　↓ |

以下のような、広い型で宣言する場合は実行でき、狭い型で宣言する場合はエラーになる。


```java
long l = 1234L; // 正しい　同じ型
float f = l;    // 正しい　flatの方が広い型
int i = f;      // コンパイルエラー。 intの方が狭い型
```

最後のような場合、キャストが必要になる。

```java
long l = 1234L; // 正しい　同じ型
float f = l;    // 正しい　flatの方が広い型。明示する必要がない(アップキャスト)
int i = (int)f; // キャストする。明示する必要がある(ダウンキャスト)
```

### 二項の数値格上げ変換

double型とint型を演算した際、値が広い型に変換される。

```java
int a = 5;
double b = 2.0;
System.out.println("a + b = " + a * b); // 出力：a + b = 10.0
```

となる。

これは、比較演算子でも同じ。

```java
int a = 5;
double b = 2.0;
boolean c = a <= b;                     // a,bともdouble型になり、比較する。
System.out.println("boolean c = " + c); // 出力；boolean c = false
```

文字などの参照型(文字列、クラス、配列)は比較の対象が参照先(メモリ)になるので、文字列が同じでも、等しくないと判定される。

文字列の比較はequals()を使う。

```java
String s1 = "hello";
String s2 = "hello";
if(s1.equals(s2)){
    System.out.println("s1 == s2");
}else{
    System.out.println("s1 != s2");
} // 出力：s1 == s2
```

### 論理演算子「&&」と「&」の違い

```java
int i = 20, j = 20;
if((i >= 40) && (++i <= 60)){ // (i >= 40))がfalseと判定したらその後の(++i <= 60)は評価されない
    System.out.println("i is middle.");
}else{
    System.out.println("i is not middle.");
}
if((j >= 40) & (++j <= 60)){ // (j >= 40))がfalseと判定した後でも(++j <= 60)も評価するため、++jを処理する
   System.out.println("j is middle.");
}else{
   System.out.println("j is not middle.");
}
System.out.println("i = " + i + ", j = " + j); // ++jという処理をしているため、iとjの値は変わる
```

実行結果

```
i is not middle.
j is not middle.
i = 20, j = 21
```

### ビット演算子

ビットごとの論理演算をする。

```java
byte b1  = 0x21, b2 = 0x55; // 16進数　10進数に直すと、b1 = 48 b2 = 125 
System.out.println("b1 & b2 = " + (b1 & b2));
/*
       0010 0001
&(AND) 0101 0101
----------------
       0000 0001
*/
System.out.println("b1 | b2 = " + (b1 | b2));
/*
      0010 0001
|(OR) 0101 0101
----------------
      0111 0101
*/
System.out.println("b1 ^ b2 = " + (b1 ^ b2));
/*
       0010 0001
^(XOR) 0101 0101
----------------
       0111 0100
*/
System.out.println("~b1 = " + (~b1));
/*
~(反転) 0010 0001
-----------------
        1101 1110
*/
```

出力結果

```
b1 & b2 = 1
b1 | b2 = 117
b1 ^ b2 = 116
~b1 = -34
```

ちなみにbyte型は、プリミティブ型で-128~127の値を示す。一番左の桁で＋ーの符号を示したような気がする。

### シフト演算子

ビット数分シフトする。

```java
int i1 = 1024, i2 = -1024; // 2進数に直すと、i1 = 10000000000(00000000000000000000010000000000) i2 = 11111111111111111111110000000000 
System.out.println("i1 << 2 = " + (i1 << 2));   // 1000000000000 
System.out.println("i1 >> 2 = " + (i1 >> 2));   // 100000000
System.out.println("i1 >>> 2 = " + (i1 >>> 2)); // 「>>>」はシフト対象(i1)が負の数でも常に正を返す
System.out.println("i2 << 2 = " + (i2 << 2));   // 11111111111111111111000000000000
System.out.println("i2 >> 2 = " + (i2 >> 2));   // 11111111111111111111111100000000
System.out.println("i2 >>> 2 = " + (i2 >>> 2)); // 00111111111111111111111100000000 二桁分0を左から入れるイメージ
```

出力結果

```
i1 << 2 = 4096
i1 >> 2 = 256
i1 >>> 2 = 256
i2 << 2 = -4096
i2 >> 2 = -256
i2 >>> 2 = 1073741568
```

## 制御文

elseは直前のif文に連結する。ここでは、if(j < k)の反例処理となる。

```java
int i = 10;
int j = -10;
int k = 0;
if(i < j)
    if(j < k)
        System.out.println("i < k");
else
    System.out.println("i > j or i = j");
System.out.println("end of process.");
```

よって、出力結果は、

```
end of process.
```

となる。

## クラス

### クラスのアクセス修飾子

public:このクラスを外部(任意のパッケージの任意のクラス)からアクセスできるようにする。publicが宣言されていない場合、同じパッケージのクラスだけがアクセスできる。
　なお、1つのソースファイル(*.java)中に、public宣言したクラスを複数記述することはできません。


abstract:このクラスが「抽象クラス」であることを宣言する。


final:安全性などの理由により、このクラスからサブクラスを派生できないようにする。

### フィールドの宣言(変数のアクセス修飾子)

**アクセス修飾子**

アクセス修飾子は、このフィールドへアクセスできるクラスの範囲を指定する。

public
