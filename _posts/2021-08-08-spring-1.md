---
layout: post
title: Springメモ
author: taku
date: 2021-08-08 05:00
last_modified_at: 2022-03-27 2:50
tags: [Java, Spring]
toc:  true
---

studying Spring🍃

Springをメモる

## POJO

Plain Old Java Objectの略。

ごく普通のJavaオブジェクト

## Entityクラス

データベースのテーブルの構造を表したクラス。
データベースnの1行を1インスタンスに変換するクラス。(Map型→オブジェクト型)

データベースから取得したデータをEntityクラスに詰める。

フィールド(メンバ変数(private))、メソッド(メンバメソッド(コンストラクタ、getter, setter))がある。

```java
package entity;
public class Member {
	private int id;
	private String name;
	private String email;
	public Member() {}
	public Member(int id, String name, String email) {
		this.id = id;
		this.name = name;
		this.email = email;
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getEmail() {
		return email;
	}
	public void setEmail(String email) {
		this.email = email;
	};
}
```

## Serviceクラス

Entityのインスタンスを提供するクラス。
例)あいさつを返すメソッドや会員一覧を返すメソッドを実装する。

まず、インターフェースを作る。

### インターフェース

- 機能の概要
- to doリスト(メソッド名、引数)
- クラスを自動生成することもできる(My Batis)

などを定義しておく。その後、Implで詳しく実装する。Implの意味は「実装する」。

***インターフェース***

```java
package service;
import java.util.ArrayList;
import entity.Member;
public interface MemberService {
	String greet(int i);
	ArrayList<Member> getAll();
}
```

***実装クラス***

```java
package service;
import java.util.ArrayList;
import entity.Member;
public class MemberServiceImpl implements MemberService {
	@Override
	public String greet(int i) {
		String[] greetings = {"Good moring","Hello","Good evening"};
		return greetings[i];
	}
	@Override
	public ArrayList<Member> getAll() {
		ArrayList<Member> list = new ArrayList<>();
		Member mem1 = new Member(1,"Linda","linda@example.com");
		Member mem2 = new Member(2,"James","james@example.com");
		list.add(mem1);
		list.add(mem2);
		return list;
	}
}
```

**Mainクラス***

```java
package demo;
import java.util.ArrayList;
import entity.Member;
import service.MemberServiceImpl;
public class Main {
	public static void main(String[] args) {
		MemberServiceImpl service = new  MemberServiceImpl();
		System.out.println(service.greet(2));
		System.out.println(service.getAll());
		ArrayList<Member> list = service.getAll();
		for(Member mem : list) {
			System.out.println(mem.getId()+ ", " + mem.getName() + ", " + mem.getEmail());
		}
	}
}
```

## シングルトン

そのクラスのインスタンスが必ず1つであることを保証するデザインパターン。

デザインパターン：オブジェクト指向において色々なプログラムで再利用できる設計パターン。

例

***MemberServiceImpl.java***

```java
package service;
import java.util.ArrayList;
import entity.Member;
public class MemberServiceImpl implements MemberService {
	private static MemberServiceImpl singleton = new MemberServiceImpl();
	private MemberServiceImpl() {};
	public static MemberServiceImpl getInstance() {
		return singleton;
	}
	@Override
	public String greet(int i) {
		String[] greetings = {"Good moring","Hello","Good evening"};
		return greetings[i];
	}
	@Override
	public ArrayList<Member> getAll() {
		ArrayList<Member> list = new ArrayList<>();
		Member mem1 = new Member(1,"Linda","linda@example.com");
		Member mem2 = new Member(2,"James","james@example.com");
		list.add(mem1);
		list.add(mem2);
		return list;
	}
}

```

とすることで少し呼び出しにくくするのではないかな？、、呼び出す場合は以下のようにして呼び出す。


例
***Main.java***

```java
package demo;
import java.util.ArrayList;
import entity.Member;
import service.MemberServiceImpl;
public class Main {
	public static void main(String[] args) {
//		MemberServiceImpl service = new  MemberServiceImpl();
		MemberServiceImpl service = MemberServiceImpl.getInstance();
		System.out.println(service.greet(2));

		System.out.println(service.getAll());
		ArrayList<Member> list = service.getAll();
		for(Member mem : list) {
			System.out.println(mem.getId()+ ", " + mem.getName() + ", " + mem.getEmail());
		}
	}
}
```

## Gradle

ソースコードのコンパイル、テストを実行してレポートのを出力、クラスファイルのアーカイブ生成、アーカイブをステージング環境にリリースする、などの定型的な作業を自動化するソフトウェア(ビルドツール)。

例：make, ant, maven などがある。

Eclipseにもビルドツールはあるが、Gradleではディレクトリ構造にルールを設けることでビルドを効率化している。

## アノテーション

### @Configuration

設定ファイルだと認識され、自動で読み込まれる。

### @ControllerAdvice

何かメソッドを実行する前に、共通の処理を入れたい場合に使用する。(例)フォームの入力で空文字が飛んできた場合、nullに直す。

Controllerクラスを横断した処理を作ることができる。

### @SpringBootApplication

昔はXMLで書く必要の合った多くの設定が自動的に行われるようになった。

### @Controller

自動的にインスタンス化される。SpringにはDependancy Injection(DI)という仕組みがあり、インスタンス化したオブジェクトをいつでも使えるように保管する。

## ymlファイル

階層的に効率よく設定を記述できるファイル形式。

## Spring MVC Architecture

<img src="https://www.onlinetutorialspoint.com/wp-content/uploads/2015/04/Spring-Web-MVC-Framework-Flow.png" width="400px">

### springにおけるModelクラス

リクエストスコープを管理する。

リクエストスコープでは1回のリクエストの間、メモリ上にデータを保存できるので、Viewが必要なHTMLを作るときに必要なデータを与えることができる。

## Spring JDBC

JDBC(Java Database Connectivity)クラスをラップしている。ラップというのは「内部に
JDBCを持っている」ということだが、Spring用に簡単に扱えるようになっている。


## ステートレス

システムが現在の状態を表すデータを保持しないこと。基本的にはアクセスごとにデータを失う。次のページへデータを渡すのhiddenタグが使われたりする。

## リダイレクト

サーバがレスポンスを返したあと、もう一度クライアントがリクエストする仕組み。二重クリック防止策。

## フラッシュスコープ

一度使用したセッションを消す仕組み。

## 追記

eclipseとgithubの連携の以前一度繋いだことがあるので、簡単だったが、初めて繋ぐのはいろいろ難しいと思う。未来の自分のために書いておくべきだったと後悔している。